

<!DOCTYPE html>
<html lang="en">

<head>
  
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Framework Documentation components/canvas/CanvasContainer.tsx</title>

  <script src="https://cdn.jsdelivr.net/gh/google/code-prettify@master/loader/run_prettify.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <script src="./build/entry.js"></script>
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->
  <link href="https://fonts.googleapis.com/css?family=Roboto:100,400,700|Inconsolata,700" rel="stylesheet">
  <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.6.3/css/all.css" integrity="sha384-UHRtZLI+pbxtHCWp1t77Bi1L4ZtiqrqD80Kn4Z8NTSRyMA2Fd33n5dQ8lWUE00s/" crossorigin="anonymous">
  <link type="text/css" rel="stylesheet" href="https://jmblog.github.io/color-themes-for-google-code-prettify/themes/tomorrow-night.min.css">
  <link type="text/css" rel="stylesheet" href="styles/app.min.css">
  <link type="text/css" rel="stylesheet" href="styles/iframe.css">
  <link type="text/css" rel="stylesheet" href="">
  <script async defer src="https://buttons.github.io/buttons.js"></script>

  
</head>



<body class="layout small-header">
    <div id="stickyNavbarOverlay"></div>
    

<div class="top-nav">
    <div class="inner">
        <a id="hamburger" role="button" class="navbar-burger" aria-label="menu" aria-expanded="false">
            <span aria-hidden="true"></span>
            <span aria-hidden="true"></span>
            <span aria-hidden="true"></span>
        </a>
        <div class="logo">
            
             
                <a href="index.html">
                    <h1 class="navbar-item">framework documentation</h1>
                </a>
            
        </div>
        <div class="menu">
            
            <div class="navigation">
                <a
                    href="index.html"
                    class="link"
                >
                    Documentation
                </a>
                
                 
                    
                        <a
                            class="link user-link "
                            href="..."
                        >
                            Respository
                        </a>
                    
                
                
            </div>
        </div>
    </div>
</div>
    <div id="main">
        <div
            class="sidebar "
            id="sidebarNav"
        >
            
                <div class="search-wrapper">
                    <input id="search" type="text" placeholder="Search docs..." class="input">
                </div>
            
            <nav>
                
                    <h2><a href="index.html">Documentation</a></h2><div class="category"><h3>Namespaces</h3><ul><li><a href="PIXI.html">PIXI</a></li><li><a href="PIXI.filters.html">filters</a></li><li><a href="PIXI.graphicsUtils.html">graphicsUtils</a></li><li><a href="PIXI.groupD8.html">groupD8</a></li><li><a href="PIXI.resources.html">resources</a></li><li><a href="PIXI.settings.html">settings</a></li><li><a href="PIXI.systems.html">systems</a></li></ul><h3>Classes</h3><ul><li><a href="About.html">About</a></li><li><a href="Canvas.html">Canvas</a></li><li><a href="CropMenuProps.html">CropMenuProps</a></li><li><a href="File.html">File</a></li><li><a href="Menu.html">Menu</a></li><li><a href="PIXI.AbstractRenderer.html">AbstractRenderer</a></li><li><a href="PIXI.AccessibilityManager.html">AccessibilityManager</a></li><li><a href="PIXI.AppLoaderPlugin.html">AppLoaderPlugin</a></li><li><a href="PIXI.Application.html">Application</a></li><li><a href="PIXI.BaseRenderTexture.html">BaseRenderTexture</a></li><li><a href="PIXI.BaseTexture.html">BaseTexture</a></li><li><a href="PIXI.BlobResource.html">BlobResource</a></li><li><a href="PIXI.Bounds.html">Bounds</a></li><li><a href="PIXI.BufferSystem.html">BufferSystem</a></li><li><a href="PIXI.CompressedTextureLoader.html">CompressedTextureLoader</a></li><li><a href="PIXI.Container.html">Container</a></li><li><a href="PIXI.DDSLoader.html">DDSLoader</a></li><li><a href="PIXI.DisplayObject.html">DisplayObject</a></li><li><a href="PIXI.Extract.html">Extract</a></li><li><a href="PIXI.FillStyle.html">FillStyle</a></li><li><a href="PIXI.Framebuffer.html">Framebuffer</a></li><li><a href="PIXI.FramebufferSystem.html">FramebufferSystem</a></li><li><a href="PIXI.GLFramebuffer.html">GLFramebuffer</a></li><li><a href="PIXI.GLProgram.html">GLProgram</a></li><li><a href="PIXI.GLTexture.html">GLTexture</a></li><li><a href="PIXI.Graphics.html">Graphics</a></li><li><a href="PIXI.GraphicsData.html">GraphicsData</a></li><li><a href="PIXI.GraphicsGeometry.html">GraphicsGeometry</a></li><li><a href="PIXI.InteractionData.html">InteractionData</a></li><li><a href="PIXI.InteractionEvent.html">InteractionEvent</a></li><li><a href="PIXI.InteractionManager.html">InteractionManager</a></li><li><a href="PIXI.KTXLoader.html">KTXLoader</a></li><li><a href="PIXI.LineStyle.html">LineStyle</a></li><li><a href="PIXI.Loader.html">Loader</a></li><li><a href="PIXI.MeshBatchUvs.html">MeshBatchUvs</a></li><li><a href="PIXI.MeshGeometry.html">MeshGeometry</a></li><li><a href="PIXI.MeshMaterial.html">MeshMaterial</a></li><li><a href="PIXI.ParticleContainer.html">ParticleContainer</a></li><li><a href="PIXI.ParticleRenderer.html">ParticleRenderer</a></li><li><a href="PIXI.Point.html">Point</a></li><li><a href="PIXI.Quad.html">Quad</a></li><li><a href="PIXI.QuadUv.html">QuadUv</a></li><li><a href="PIXI.RopeGeometry.html">RopeGeometry</a></li><li><a href="PIXI.RoundedRectangle.html">RoundedRectangle</a></li><li><a href="PIXI.Texture.html">Texture</a></li><li><a href="PIXI.TextureGCSystem.html">TextureGCSystem</a></li><li><a href="PIXI.TextureMatrix.html">TextureMatrix</a></li><li><a href="PIXI.TextureSystem.html">TextureSystem</a></li><li><a href="PIXI.TextureUvs.html">TextureUvs</a></li><li><a href="PIXI.Ticker.html">Ticker</a></li><li><a href="PIXI.TickerPlugin.html">TickerPlugin</a></li><li><a href="PIXI.TilingSpriteRenderer.html">TilingSpriteRenderer</a></li><li><a href="PIXI.UniformGroup.html">UniformGroup</a></li><li><a href="PIXI.ViewableBuffer.html">ViewableBuffer</a></li><li><a href="PIXI.filters.BlurFilterPass.html">BlurFilterPass</a></li><li><a href="PIXI.graphicsUtils.BatchPart.html">BatchPart</a></li><li><a href="PIXI.utils.CanvasRenderTarget.html">CanvasRenderTarget</a></li><li><a href="People.html">People</a></li><li><a href="SamplingComp.html">SamplingComp</a></li><li><a href="SignalBinding.html">SignalBinding</a></li><li><a href="SlicesMenu.html">SlicesMenu</a></li><li><a href="ThemeToggle.html">ThemeToggle</a></li></ul><h3>Interfaces</h3><ul><li><a href="CropAxisInterface.html">CropAxisInterface</a></li><li><a href="ErrorInterface.html">ErrorInterface</a></li><li><a href="HistogramInfoPayload.html">HistogramInfoPayload</a></li><li><a href="ImageShapeInterface.html">ImageShapeInterface</a></li><li><a href="IonRangeElement.html">IonRangeElement</a></li><li><a href="LabelInterface.html">LabelInterface</a></li><li><a href="MenuItem.html">MenuItem</a></li><li><a href="MultiplesPath.html">MultiplesPath</a></li><li><a href="OffscreenCanvas.html">OffscreenCanvas</a></li><li><a href="PIXI.IHitArea.html">IHitArea</a></li><li><a href="PIXI.utils.DecomposedDataUri.html">DecomposedDataUri</a></li><li><a href="PatchesInterface.html">PatchesInterface</a></li><li><a href="QueueToast.html">QueueToast</a></li><li><a href="SamplingInterface.html">SamplingInterface</a></li><li><a href="SelectInterface.html">SelectInterface</a></li><li><a href="SharedArrayBuffer.html">SharedArrayBuffer</a></li><li><a href="TableElement.html">TableElement</a></li><li><a href="TableInterface.html">TableInterface</a></li><li><a href="dataType.html">dataType</a></li><li><a href="multiplesPath_.html">multiplesPath</a></li><li>{LabelEditProps}</li><li>{<a href="LabelInterface.html">LabelInterface</a>}</li><li>{LoadingComponentInterface}</li></ul><h3>Events</h3><ul><li><a href="PIXI.BaseRenderTexture.html#event:dispose">dispose</a></li><li><a href="PIXI.BaseRenderTexture.html#event:error">error</a></li><li><a href="PIXI.BaseRenderTexture.html#event:loaded">loaded</a></li><li><a href="PIXI.BaseRenderTexture.html#event:update">update</a></li><li><a href="PIXI.BaseTexture.html#event:dispose">dispose</a></li><li><a href="PIXI.BaseTexture.html#event:error">error</a></li><li><a href="PIXI.BaseTexture.html#event:loaded">loaded</a></li><li><a href="PIXI.BaseTexture.html#event:update">update</a></li><li><a href="PIXI.Container.html#event:click">click</a></li><li><a href="PIXI.Container.html#event:mousedown">mousedown</a></li><li><a href="PIXI.Container.html#event:mousemove">mousemove</a></li><li><a href="PIXI.Container.html#event:mouseout">mouseout</a></li><li><a href="PIXI.Container.html#event:mouseover">mouseover</a></li><li><a href="PIXI.Container.html#event:mouseup">mouseup</a></li><li><a href="PIXI.Container.html#event:mouseupoutside">mouseupoutside</a></li><li><a href="PIXI.Container.html#event:pointercancel">pointercancel</a></li><li><a href="PIXI.Container.html#event:pointerdown">pointerdown</a></li><li><a href="PIXI.Container.html#event:pointermove">pointermove</a></li><li><a href="PIXI.Container.html#event:pointerout">pointerout</a></li><li><a href="PIXI.Container.html#event:pointerover">pointerover</a></li><li><a href="PIXI.Container.html#event:pointertap">pointertap</a></li><li><a href="PIXI.Container.html#event:pointerup">pointerup</a></li><li><a href="PIXI.Container.html#event:pointerupoutside">pointerupoutside</a></li><li><a href="PIXI.Container.html#event:rightclick">rightclick</a></li><li><a href="PIXI.Container.html#event:rightdown">rightdown</a></li><li><a href="PIXI.Container.html#event:rightup">rightup</a></li><li><a href="PIXI.Container.html#event:rightupoutside">rightupoutside</a></li><li><a href="PIXI.Container.html#event:tap">tap</a></li><li><a href="PIXI.Container.html#event:touchcancel">touchcancel</a></li><li><a href="PIXI.Container.html#event:touchend">touchend</a></li><li><a href="PIXI.Container.html#event:touchendoutside">touchendoutside</a></li><li><a href="PIXI.Container.html#event:touchmove">touchmove</a></li><li><a href="PIXI.Container.html#event:touchstart">touchstart</a></li><li><a href="PIXI.DisplayObject.html#event:click">click</a></li><li><a href="PIXI.DisplayObject.html#event:mousedown">mousedown</a></li><li><a href="PIXI.DisplayObject.html#event:mousemove">mousemove</a></li><li><a href="PIXI.DisplayObject.html#event:mouseout">mouseout</a></li><li><a href="PIXI.DisplayObject.html#event:mouseover">mouseover</a></li><li><a href="PIXI.DisplayObject.html#event:mouseup">mouseup</a></li><li><a href="PIXI.DisplayObject.html#event:mouseupoutside">mouseupoutside</a></li><li><a href="PIXI.DisplayObject.html#event:pointercancel">pointercancel</a></li><li><a href="PIXI.DisplayObject.html#event:pointerdown">pointerdown</a></li><li><a href="PIXI.DisplayObject.html#event:pointermove">pointermove</a></li><li><a href="PIXI.DisplayObject.html#event:pointerout">pointerout</a></li><li><a href="PIXI.DisplayObject.html#event:pointerover">pointerover</a></li><li><a href="PIXI.DisplayObject.html#event:pointertap">pointertap</a></li><li><a href="PIXI.DisplayObject.html#event:pointerup">pointerup</a></li><li><a href="PIXI.DisplayObject.html#event:pointerupoutside">pointerupoutside</a></li><li><a href="PIXI.DisplayObject.html#event:rightclick">rightclick</a></li><li><a href="PIXI.DisplayObject.html#event:rightdown">rightdown</a></li><li><a href="PIXI.DisplayObject.html#event:rightup">rightup</a></li><li><a href="PIXI.DisplayObject.html#event:rightupoutside">rightupoutside</a></li><li><a href="PIXI.DisplayObject.html#event:tap">tap</a></li><li><a href="PIXI.DisplayObject.html#event:touchcancel">touchcancel</a></li><li><a href="PIXI.DisplayObject.html#event:touchend">touchend</a></li><li><a href="PIXI.DisplayObject.html#event:touchendoutside">touchendoutside</a></li><li><a href="PIXI.DisplayObject.html#event:touchmove">touchmove</a></li><li><a href="PIXI.DisplayObject.html#event:touchstart">touchstart</a></li><li><a href="PIXI.Graphics.html#event:click">click</a></li><li><a href="PIXI.Graphics.html#event:mousedown">mousedown</a></li><li><a href="PIXI.Graphics.html#event:mousemove">mousemove</a></li><li><a href="PIXI.Graphics.html#event:mouseout">mouseout</a></li><li><a href="PIXI.Graphics.html#event:mouseover">mouseover</a></li><li><a href="PIXI.Graphics.html#event:mouseup">mouseup</a></li><li><a href="PIXI.Graphics.html#event:mouseupoutside">mouseupoutside</a></li><li><a href="PIXI.Graphics.html#event:pointercancel">pointercancel</a></li><li><a href="PIXI.Graphics.html#event:pointerdown">pointerdown</a></li><li><a href="PIXI.Graphics.html#event:pointermove">pointermove</a></li><li><a href="PIXI.Graphics.html#event:pointerout">pointerout</a></li><li><a href="PIXI.Graphics.html#event:pointerover">pointerover</a></li><li><a href="PIXI.Graphics.html#event:pointertap">pointertap</a></li><li><a href="PIXI.Graphics.html#event:pointerup">pointerup</a></li><li><a href="PIXI.Graphics.html#event:pointerupoutside">pointerupoutside</a></li><li><a href="PIXI.Graphics.html#event:rightclick">rightclick</a></li><li><a href="PIXI.Graphics.html#event:rightdown">rightdown</a></li><li><a href="PIXI.Graphics.html#event:rightup">rightup</a></li><li><a href="PIXI.Graphics.html#event:rightupoutside">rightupoutside</a></li><li><a href="PIXI.Graphics.html#event:tap">tap</a></li><li><a href="PIXI.Graphics.html#event:touchcancel">touchcancel</a></li><li><a href="PIXI.Graphics.html#event:touchend">touchend</a></li><li><a href="PIXI.Graphics.html#event:touchendoutside">touchendoutside</a></li><li><a href="PIXI.Graphics.html#event:touchmove">touchmove</a></li><li><a href="PIXI.Graphics.html#event:touchstart">touchstart</a></li><li><a href="PIXI.InteractionManager.html#event:click">click</a></li><li><a href="PIXI.InteractionManager.html#event:mousedown">mousedown</a></li><li><a href="PIXI.InteractionManager.html#event:mousemove">mousemove</a></li><li><a href="PIXI.InteractionManager.html#event:mouseout">mouseout</a></li><li><a href="PIXI.InteractionManager.html#event:mouseover">mouseover</a></li><li><a href="PIXI.InteractionManager.html#event:mouseup">mouseup</a></li><li><a href="PIXI.InteractionManager.html#event:mouseupoutside">mouseupoutside</a></li><li><a href="PIXI.InteractionManager.html#event:pointercancel">pointercancel</a></li><li><a href="PIXI.InteractionManager.html#event:pointerdown">pointerdown</a></li><li><a href="PIXI.InteractionManager.html#event:pointermove">pointermove</a></li><li><a href="PIXI.InteractionManager.html#event:pointerout">pointerout</a></li><li><a href="PIXI.InteractionManager.html#event:pointerover">pointerover</a></li><li><a href="PIXI.InteractionManager.html#event:pointertap">pointertap</a></li><li><a href="PIXI.InteractionManager.html#event:pointerup">pointerup</a></li><li><a href="PIXI.InteractionManager.html#event:pointerupoutside">pointerupoutside</a></li><li><a href="PIXI.InteractionManager.html#event:rightclick">rightclick</a></li><li><a href="PIXI.InteractionManager.html#event:rightdown">rightdown</a></li><li><a href="PIXI.InteractionManager.html#event:rightup">rightup</a></li><li><a href="PIXI.InteractionManager.html#event:rightupoutside">rightupoutside</a></li><li><a href="PIXI.InteractionManager.html#event:tap">tap</a></li><li><a href="PIXI.InteractionManager.html#event:touchcancel">touchcancel</a></li><li><a href="PIXI.InteractionManager.html#event:touchend">touchend</a></li><li><a href="PIXI.InteractionManager.html#event:touchendoutside">touchendoutside</a></li><li><a href="PIXI.InteractionManager.html#event:touchmove">touchmove</a></li><li><a href="PIXI.InteractionManager.html#event:touchstart">touchstart</a></li><li><a href="PIXI.ParticleContainer.html#event:click">click</a></li><li><a href="PIXI.ParticleContainer.html#event:mousedown">mousedown</a></li><li><a href="PIXI.ParticleContainer.html#event:mousemove">mousemove</a></li><li><a href="PIXI.ParticleContainer.html#event:mouseout">mouseout</a></li><li><a href="PIXI.ParticleContainer.html#event:mouseover">mouseover</a></li><li><a href="PIXI.ParticleContainer.html#event:mouseup">mouseup</a></li><li><a href="PIXI.ParticleContainer.html#event:mouseupoutside">mouseupoutside</a></li><li><a href="PIXI.ParticleContainer.html#event:pointercancel">pointercancel</a></li><li><a href="PIXI.ParticleContainer.html#event:pointerdown">pointerdown</a></li><li><a href="PIXI.ParticleContainer.html#event:pointermove">pointermove</a></li><li><a href="PIXI.ParticleContainer.html#event:pointerout">pointerout</a></li><li><a href="PIXI.ParticleContainer.html#event:pointerover">pointerover</a></li><li><a href="PIXI.ParticleContainer.html#event:pointertap">pointertap</a></li><li><a href="PIXI.ParticleContainer.html#event:pointerup">pointerup</a></li><li><a href="PIXI.ParticleContainer.html#event:pointerupoutside">pointerupoutside</a></li><li><a href="PIXI.ParticleContainer.html#event:rightclick">rightclick</a></li><li><a href="PIXI.ParticleContainer.html#event:rightdown">rightdown</a></li><li><a href="PIXI.ParticleContainer.html#event:rightup">rightup</a></li><li><a href="PIXI.ParticleContainer.html#event:rightupoutside">rightupoutside</a></li><li><a href="PIXI.ParticleContainer.html#event:tap">tap</a></li><li><a href="PIXI.ParticleContainer.html#event:touchcancel">touchcancel</a></li><li><a href="PIXI.ParticleContainer.html#event:touchend">touchend</a></li><li><a href="PIXI.ParticleContainer.html#event:touchendoutside">touchendoutside</a></li><li><a href="PIXI.ParticleContainer.html#event:touchmove">touchmove</a></li><li><a href="PIXI.ParticleContainer.html#event:touchstart">touchstart</a></li><li><a href="PIXI.html#.Renderer#event:context">context</a></li><li><a href="PIXI.html#.Renderer#event:postrender">postrender</a></li><li><a href="PIXI.html#.Renderer#event:prerender">prerender</a></li><li><a href="PIXI.html#.Renderer#event:resize">resize</a></li><li><a href="global.html#event:added">added</a></li><li><a href="global.html#event:destroyed">destroyed</a></li><li><a href="global.html#event:removed">removed</a></li></ul><h3>Global</h3><ul><li><a href="global.html#AddNewFile">AddNewFile</a></li><li><a href="global.html#App">App</a></li><li><a href="global.html#AugmentationComp">AugmentationComp</a></li><li><a href="global.html#BatchInferenceComp">BatchInferenceComp</a></li><li><a href="global.html#Colormap">Colormap</a></li><li><a href="global.html#CreateDatasetH5">CreateDatasetH5</a></li><li><a href="global.html#DatasetComp">DatasetComp</a></li><li><a href="global.html#DeepLearning">DeepLearning</a></li><li><a href="global.html#DeepLoadingComp">DeepLoadingComp</a></li><li><a href="global.html#DeleteAllWindow">DeleteAllWindow</a></li><li><a href="global.html#EditLabelMenu">EditLabelMenu</a></li><li><a href="global.html#ErrorWindowComp">ErrorWindowComp</a></li><li><a href="global.html#FileLoadDialog">FileLoadDialog</a></li><li><a href="global.html#FileNameComp">FileNameComp</a></li><li><a href="global.html#FileSaveDialog">FileSaveDialog</a></li><li><a href="global.html#InferenceComp">InferenceComp</a></li><li><a href="global.html#InitAugmentationOptions">InitAugmentationOptions</a></li><li><a href="global.html#InputFileComp">InputFileComp</a></li><li><a href="global.html#InputLabel">InputLabel</a></li><li><a href="global.html#MenuContentRange">MenuContentRange</a></li><li><a href="global.html#OptionsIcons">OptionsIcons</a></li><li><a href="global.html#Page">Page</a></li><li><a href="global.html#Remote">Remote</a></li><li><a href="global.html#Settings">Settings</a></li><li><a href="global.html#SideMenuAnnot">SideMenuAnnot</a></li><li><a href="global.html#WarningWindow">WarningWindow</a></li><li><a href="global.html#WorkspaceComp">WorkspaceComp</a></li><li><a href="global.html#dispatch">dispatch</a></li><li><a href="global.html#dtypeList">dtypeList</a></li><li><a href="global.html#encodeBinary">encodeBinary</a></li><li><a href="global.html#extract">extract</a></li><li><a href="global.html#get">get</a></li><li><a href="global.html#initialOutput">initialOutput</a></li><li><a href="global.html#initialPatches">initialPatches</a></li><li><a href="global.html#punycode">punycode</a></li><li><a href="global.html#set">set</a></li><li><a href="global.html#sfetch">sfetch</a></li><li><a href="global.html#subscribe">subscribe</a></li><li><a href="global.html#typePM">typePM</a></li><li><a href="global.html#unsubscribe">unsubscribe</a></li><li><a href="global.html#useEventBus">useEventBus</a></li></ul></div>
                
            </nav>
        </div>
        <div class="core" id="main-content-wrapper">
            <div class="content">
                <header class="page-title">
                    <p>Source</p>
                    <h1>components/canvas/CanvasContainer.tsx</h1>
                </header>
                



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>import {Component} from 'react';
import {IonFab, IonFabButton, IonIcon} from '@ionic/react';
import {expand, brush, browsers, add, remove, eye, eyeOff} from 'ionicons/icons';
import {debounce, isEqual} from "lodash";
import * as PIXI from 'pixi.js';
//warning: this pixi.js version is modified to use a custom loader on webgl with gl.pixelStorei(gl.UNPACK_ALIGNMENT, 1);
// https://stackoverflow.com/questions/42789896/webgl-error-arraybuffer-not-big-enough-for-request-in-case-of-gl-luminance
// this fix is on the import on utils/pixibufferloader
import '../../utils/pixibufferloader';
import * as pixi_viewport from 'pixi-viewport';

import {NdArray, TypedArray} from 'ndarray';
import {clamp} from '../../utils/math';
import {sfetch} from '../../utils/simplerequest';

import './CanvasContainer.css';
import MenuFabButton from './MenuFabButton';
import {dispatch, subscribe, unsubscribe} from '../../utils/eventbus';
import {defaultColormap} from '../../utils/colormap';
import {CropAxisInterface, CropShapeInterface} from '../tools_menu/utils/CropInterface';
import {ImageShapeInterface} from '../tools_menu/utils/ImageShapeInterface';
import {ImageInfoInterface} from '../main_menu/file/utils/ImageInfoInterface';

class Brush {

    label: number;
    size: number = 0;
    color: number;
    radius: number = 0;

    mode: brush_mode_type = 'draw_brush';
    maintainExtendLabel: boolean;

    canvas: HTMLCanvasElement;
    context: CanvasRenderingContext2D;

    cursor: PIXI.Graphics;

    colors: Array&lt;[number, number, number]>;

    constructor(colors: [number, number, number][]) {
        this.label = 0;
        this.color = 0xffffff;
        this.maintainExtendLabel = false;

        this.canvas = document.createElement('canvas');

        this.context = this.canvas.getContext('2d')!;

        this.colors = colors;

        this.cursor = this.createBrush();

        this.setSize(4);

        this.update();
    }

    setMode(mode: brush_mode_type) {
        console.log('set mode: ', mode);
        this.mode = mode;
        this.update();
    }

    private updateBrush() {
        const gr = this.cursor;
        gr.clear();
        gr.beginFill(this.color);
        gr.drawCircle(this.size / 2, this.size / 2, this.radius);
        gr.endFill();
        console.log(this.color);
    }

    private createBrush() {
        const cursor = new PIXI.Graphics();
        cursor.alpha = 0.5;
        return cursor;
    }

    contextDrawBrush(context: CanvasRenderingContext2D, x: number, y: number) {
        const [r, g, b] = this.colors[(this.label) % this.colors.length];
        context.beginPath();
        context.fillStyle = `rgb(${r},${g},${b})`;
        context.arc(x, y, this.radius, 0, 2 * Math.PI);
        context.fill();
    }

    setLabel(l: number) {
        this.label = l;
        this.update();
    }

    setSize(s: number) {
        this.size = s;

        this.canvas.width = this.size;
        this.canvas.height = this.size;
        this.radius = s / 2;

        this.update();
    }

    updateColor() {
        const color = this.colors[(this.label) % this.colors.length];
        console.log("color type : ", color);
        this.color = this.rgbToHex(...color);
    }

    private rgbToHex(r: number, g: number, b: number) {
        const bin = (r &lt;&lt; 16) | (g &lt;&lt; 8) | b;
        return bin;
    }

    update() {
        if (this.mode === 'draw_brush') {
            const color = this.colors[(this.label) % this.colors.length];
            this.color = this.rgbToHex(...color);
            this.cursor.visible = true;
        } else if (this.mode === 'erase_brush') {
            this.color = 0xFFFFFF;
            this.cursor.visible = true;
        } else {
            this.cursor.visible = false;
        }
        this.updateBrush();
    }
}


class Annotation {

    canvas: HTMLCanvasElement;
    context: CanvasRenderingContext2D;

    sprite: PIXI.Sprite;

    colors: [number, number, number][];

    annotData?: NdArray&lt;TypedArray>;

    constructor(colors: [number, number, number][]) {
        this.canvas = document.createElement('canvas');
        //this.canvas.width = 0;
        //this.canvas.height = 0;

        this.context = this.canvas.getContext('2d')!;

        this.sprite = new PIXI.Sprite();
        //this.sprite.tint = 0x00ff00;

        this.colors = colors;

        this.sprite.texture = PIXI.Texture.from(this.canvas);
    }

    setSize(x: number, y: number) {
        //avoid calling canvas resize unecessarily
        if (this.canvas.width !== x || this.canvas.height !== y) {
            this.canvas.width = x;
            this.canvas.height = y;
        }
    }

    clear() {
        this.context.clearRect(0, 0, this.canvas.width, this.canvas.height);
        this.sprite.texture.update();
    }

    update() {
        if (this.annotData) {
            this.draw(this.annotData);
        }
    }

    draw(slice: NdArray&lt;TypedArray>) {

        this.annotData = slice;

        const colors = this.colors;

        console.log('draw slice: ', slice.shape);

        this.clear();
        this.setSize(slice.shape[1], slice.shape[0]);

        const imageData = this.context.getImageData(0, 0, this.canvas.width, this.canvas.height);

        const data = imageData.data;

        for (let i = 0; i &lt; slice.data.length; i++) {
            if (slice.data[i] >= 0) {
                const color = colors[(slice.data[i]) % colors.length];
                data[i * 4] = color[0];
                data[i * 4 + 1] = color[1];
                data[i * 4 + 2] = color[2];
                data[i * 4 + 3] = 255;
            }
        }
        this.context.putImageData(imageData, 0, 0);
        this.sprite.texture.update();
    }
}


class Canvas {
    /* ... */

    app: PIXI.Application;
    viewport: pixi_viewport.Viewport;

    div: HTMLDivElement;

    prevPosition: any;

    isPainting: boolean;
    extendLabel: boolean;
    maintainExtendLabel: boolean;
    mergeLabel: boolean;

    annotation: Annotation;
    brush: Brush;

    brush_mode: brush_mode_type;

    canvas: HTMLCanvasElement;
    context: CanvasRenderingContext2D;

    slice: PIXI.Sprite;
    labelSlice: PIXI.Sprite;
    superpixelSlice: PIXI.Sprite;
    futureSlice: PIXI.Sprite;
    cropSlice: PIXI.Sprite;

    superpixelColor: number = 0xff0000;
    cropColor: number = 0xff0000;

    colors: [number, number, number][];

    x: number;
    y: number;

    imgData?: NdArray&lt;TypedArray>;
    labelData?: NdArray&lt;TypedArray>;
    futureData?: NdArray&lt;TypedArray>;

    imageShape?: ImageShapeInterface;
    cropShape?: CropShapeInterface;

    labelTableLen: number = 0;

    imgMin: number = 0.0;
    imgMax: number = 1.0;

    axis: 'XY' | 'XZ' | 'YZ';
    sliceNum: number;

    pointsBuffer: [number, number][] = [];
    activateSequentialLabel: boolean;

    constructor(div: HTMLDivElement, colors: [number, number, number][], axis: 'XY' | 'XZ' | 'YZ', sliceNum: number) {
        PIXI.settings.SCALE_MODE = PIXI.SCALE_MODES.NEAREST;

        this.app = new PIXI.Application({
            //backgroundAlpha: 0.99,
            backgroundColor: 0x303030
        });

        this.viewport = new pixi_viewport.Viewport({
            interaction: this.app.renderer.plugins.interaction,
        });
        this.viewport.drag({
            mouseButtons: 'middle',
        });
        this.viewport.wheel();
        this.viewport.pinch();

        this.slice = new PIXI.Sprite();
        this.slice.visible = true;
        this.extendLabel = false;
        this.maintainExtendLabel = false;
        this.mergeLabel = false;

        this.labelSlice = new PIXI.Sprite();

        this.cropSlice = new PIXI.Sprite();
        this.cropSlice.tint = this.cropColor;
        this.cropSlice.alpha = 0.2;
        this.cropSlice.blendMode = PIXI.BLEND_MODES.ADD;
        this.cropSlice.visible = false;

        this.futureSlice = new PIXI.Sprite();
        this.futureSlice.visible = false;

        this.canvas = document.createElement('canvas');
        this.context = this.canvas.getContext('2d')!;

        this.superpixelSlice = new PIXI.Sprite();
        this.superpixelSlice.tint = this.superpixelColor;
        this.superpixelSlice.alpha = 0.3;
        this.superpixelSlice.blendMode = PIXI.BLEND_MODES.ADD;
        this.superpixelSlice.scale.x = 0.5;
        this.superpixelSlice.scale.y = 0.5;
        this.superpixelSlice.visible = true;

        this.annotation = new Annotation(colors);
        this.brush = new Brush(colors);
        this.brush_mode = 'draw_brush';

        this.colors = colors;

        this.isPainting = false;
        this.prevPosition = null;

        this.app.stage.addChild(this.viewport);
        this.viewport.addChild(this.slice);
        this.viewport.addChild(this.futureSlice);
        this.viewport.addChild(this.superpixelSlice);
        this.viewport.addChild(this.labelSlice);
        this.viewport.addChild(this.cropSlice);
        this.viewport.addChild(this.annotation.sprite);
        this.viewport.addChild(this.brush.cursor);

        this.viewport.on('pointerdown', (e) => this.onPointerDown(e));
        this.viewport.on('pointerup', (e) => this.onPointerUp(e));
        this.viewport.on('pointerout', (e) => this.onPointerUp(e));
        this.viewport.on('pointermove', (e) => this.onPointerMove(e));
        this.viewport.on('wheel', (e) => this.onPointerMove(e.event));

        this.div = div;
        this.div.appendChild(this.app.view);

        this.x = this.y = 0;

        this.axis = axis;
        this.sliceNum = sliceNum;

        this.activateSequentialLabel = false;

        this.setLabelVisibility(true);
    }

    setColor(colors: { id: number, color: [number, number, number] }[]) {

        colors.forEach((color) => {
            this.colors[color.id] = color.color;
        });

        this.labelTableLen = colors.length;

        if (this.labelData) {
            this.setLabelImage(this.labelData);
        }

        this.annotation.update();
        this.brush.update();
    }

    getLabelTableLen() {
        return this.labelTableLen
    }

    setImageShape() {
        sfetch('POST', '/get_image_info/image_info', '', 'json')
            .then((imgInfo: ImageInfoInterface) => {
                const imageShape: ImageShapeInterface = {
                    x: imgInfo.imageShape.x,
                    y: imgInfo.imageShape.y,
                    z: imgInfo.imageShape.z
                };
                this.imageShape = imageShape;
                console.log('Canvas: Getting imageShape from the backend: ', imageShape);
            });
    }

    setSliceNum(sliceNum: number) {
        this.sliceNum = sliceNum;
    }

    showBrush(flag: boolean) {
        this.brush.cursor.visible = flag;
    }

    setAxis(axis: 'XY' | 'XZ' | 'YZ') {
        this.axis = axis;
    }

    onPointerDown(event: any) {
        if (event.data.pointerType === 'mouse') {
            if (event.data.button !== 0) return;
        } else if (event.data.pointerType === 'touch') {
            this.viewport.plugins.pause('drag');
            // canvas.brush.cursor.visible = false;
        }

        this.isPainting = true;
        this.prevPosition = this.viewport.toWorld(event.data.global);
    }


    onPointerMove(event: any) {

        let currPosition;

        if (event.type === 'wheel') {
            this.viewport.plugins.resume('drag');
            currPosition = this.viewport.toWorld(event.offsetX, event.offsetY);
        } else {
            currPosition = this.viewport.toWorld(event.data.global);
            if (event.data.pointerType === 'touch' &amp;&amp; event.data.originalEvent.touches.length > 1) {
                this.isPainting = false;
                return;
            }
        }

        this.brush.cursor.position.x = currPosition.x - this.brush.size / 2;
        this.brush.cursor.position.y = currPosition.y - this.brush.size / 2;

        if (!this.isPainting) return;

        this.pointsBuffer = [...this.pointsBuffer, ...this.draw(currPosition)];

        this.prevPosition = currPosition;
    }


    onPointerUp(event: any) {

        this.viewport.plugins.resume('drag');

        if (!this.isPainting)
            return;

        const currPosition = this.viewport.toWorld(event.data.global);
        this.prevPosition = currPosition;
        this.pointsBuffer = [...this.pointsBuffer, ...this.draw(currPosition)];

        const data = {
            'coords': this.pointsBuffer,
            'slice': this.sliceNum,
            'axis': this.axis,
            'size': this.brush.size,
            'label': this.brush.label,
            'mode': this.brush_mode,
        };
        sfetch('POST', '/draw', JSON.stringify(data))
            .then((success) => {
                console.log(success);
                dispatch("annotationChanged", null);
            });

        this.pointsBuffer = [];

        console.log("finish drawing on onPointerUp in Canvas");
        if (this.activateSequentialLabel) {
            dispatch("sequentialLabelUpdate", {
                id: this.brush.label,
                tableLen: this.labelTableLen
            });
            this.brush.setLabel(this.brush.label + 1);
        }
        this.isPainting = false;
    }

    distanceBetween(point1: PIXI.Point, point2: PIXI.Point) {
        return Math.sqrt(Math.pow(point2.x - point1.x, 2) + Math.pow(point2.y - point1.y, 2));
    }

    angleBetween(point1: PIXI.Point, point2: PIXI.Point) {
        return Math.atan2(point2.x - point1.x, point2.y - point1.y);
    }

    adjustContrast(minimum: number, maximum: number) {
        this.imgMax = maximum;
        this.imgMin = minimum;
        if (this.imgData) {
            this.setImage(this.imgData);
        }
    }

    setExtendLabel(flag: boolean) {
        this.extendLabel = flag
    }

    draw(currPosition: PIXI.Point): [number, number][] {

        const context = this.annotation.context;
        const mode = this.brush_mode;

        if (mode === 'no_brush') {
            return [];
        } else if (this.extendLabel) {
            this.extendLabel = false;
            this.brush.cursor.visible = false;

            const data = {
                "x_coord": Math.round(this.prevPosition.x),
                "y_coord": Math.round(this.prevPosition.y),
                "slice": this.sliceNum,
                "axis": this.axis,
            }

            console.log("Finding label by click");
            sfetch("POST", "/find_label_by_click", JSON.stringify(data), "json").then(
                (labelId: number) => {
                    console.log("label ID found : ", labelId);
                    if (labelId >= 0) {
                        this.brush.setLabel(labelId)
                        this.brush.updateColor();
                        this.setBrushMode("draw_brush");
                    }
                    this.brush.cursor.visible = true;
                    dispatch("changeSelectedLabel", labelId);
                    dispatch("isExtendLabelActivated", false);
                }
            );
            return []
        } else if (mode === 'erase_brush') {
            this.annotation.context.globalCompositeOperation = 'destination-out';
        } else {
            this.annotation.context.globalCompositeOperation = 'source-over';
        }

        if (currPosition === this.prevPosition) {
            const x = this.prevPosition.x;
            const y = this.prevPosition.y;
            console.log("They're equal :D ", currPosition);
            this.brush.contextDrawBrush(context, x, y);

            this.annotation.sprite.texture.update();

            dispatch("extendLabelOnMerge", this.maintainExtendLabel);

            return [
                [x, y],
            ];
        }

        const coords: [number, number][] = [];
        const dist = this.distanceBetween(this.prevPosition, currPosition);
        const angle = this.angleBetween(this.prevPosition, currPosition);
        for (let i = 0; i &lt; dist; i++) {
            const x = this.prevPosition.x + Math.sin(angle) * i;
            const y = this.prevPosition.y + Math.cos(angle) * i;
            this.brush.contextDrawBrush(context, x, y);
            coords.push([x, y]);
        }
        this.annotation.sprite.texture.update();
        return coords;
    }

    setBrushMode(mode: brush_mode_type) {
        this.brush_mode = mode;
        this.brush.setMode(mode);
    }

    setSuperpixelVisibility(visible: boolean = true) {
        this.superpixelSlice.visible = visible;
    }

    setAnnotationVisibility(visible: boolean = true) {
        this.annotation.sprite.visible = visible;
    }

    setAnnotationAlpha(alpha: number) {
        this.annotation.sprite.alpha = alpha;
    }

    setLabelAlpha(alpha: number) {
        this.labelSlice.alpha = alpha;
    }

    setCropAlpha(alpha: number) {
        this.cropSlice.alpha = alpha;
    }

    setPreviewVisibility(visible: boolean = true) {
        this.futureSlice.visible = visible;
    }

    setLabelVisibility(visible: boolean = true) {
        this.labelSlice.visible = visible;
    }

    /** Changes the visibility of the crop layer listening an event on CanvasContainer */
    setCropVisibility(visible: boolean = false) {
        console.log('Canvas: Changing visibility', visible);
        if (visible) {
            this.setCropPreviewMaskImage();
        }
        this.cropSlice.visible = visible;
    }

    setSequentialLabel(payload: boolean) {
        this.activateSequentialLabel = payload;
    }

    /** From an event listener of changes in axis and slices,
     * checks if the canvas is in crop preview mode and calls the
     * function that builds the preview mask if so. */
    checkUpdateCropPreview() {
        if (this.cropSlice.visible) {
            this.setCropPreviewMaskImage();
        }
    }

    private textureFromSlice(slice: Uint8Array, x: number, y: number, pformat = PIXI.FORMATS.LUMINANCE) {
        const texture = PIXI.Texture.fromBuffer(slice, x, y, {
            type: PIXI.TYPES.UNSIGNED_BYTE,
            format: pformat,
        });
        return texture;
    }

    setLabelImage(labelSlice: NdArray&lt;TypedArray>) {

        this.labelData = labelSlice;

        const width = labelSlice.shape[1];
        const height = labelSlice.shape[0];

        const len = labelSlice.data.length;
        let rgbaData = new Uint8Array(len * 4);

        const colors = this.colors;

        for (let i = 0; i &lt; len; ++i) {
            const idx = i * 4;
            const label = labelSlice.data[i];
            if (label &lt;= 0)
                continue;

            const color = colors[label];
            rgbaData[idx] = color[0];
            rgbaData[idx + 1] = color[1];
            rgbaData[idx + 2] = color[2];
            rgbaData[idx + 3] = 128;
        }

        const texture = this.textureFromSlice(rgbaData, width, height, PIXI.FORMATS.RGBA);
        this.labelSlice.texture = texture;
    }

    /** Sets the crop shape from an envent listener on CanvasContainer */
    setCropShape(cropShape: CropShapeInterface) {
        this.cropShape = cropShape;
    }

    /**
     * Builds a mask layer for the preview mode for the current slice and axis on canvas
     * with information set on Canvas by event listeners.
     * The resulting image is set on the cropSlice layer on canvas.
     */
    private setCropPreviewMaskImage() {

        let error: string;

        if (this.imageShape === undefined) {
            error = 'Canvas.setCropPreviewMaskImage: imageShape is undefined';
            console.log(error);
            return
        }

        let width: number;
        let height: number;
        const depth = this.sliceNum;

        let cropW: CropAxisInterface;
        let cropH: CropAxisInterface;
        let cropD: CropAxisInterface;

        if (this.axis === 'XY') {
            width = this.imageShape!!.x;
            height = this.imageShape!!.y;
            cropW = this.cropShape!!.cropX;
            cropH = this.cropShape!!.cropY;
            cropD = this.cropShape!!.cropZ;
        } else if (this.axis === 'XZ') {
            width = this.imageShape!!.x;
            height = this.imageShape!!.z;
            cropW = this.cropShape!!.cropX;
            cropH = this.cropShape!!.cropZ;
            cropD = this.cropShape!!.cropY;
        } else if (this.axis === 'YZ') {
            width = this.imageShape!!.y;
            height = this.imageShape!!.z;
            cropW = this.cropShape!!.cropY;
            cropH = this.cropShape!!.cropZ;
            cropD = this.cropShape!!.cropX;
        } else {
            if (this.cropShape === undefined) {
                error = 'Canvas.setCropPreviewMaskImage: cropShape is undefined';
            } else {
                error = 'Canvas.setCropPreviewMaskImage: error setting dimensions in axis: ' + this.axis;
            }
            console.log(error);
            return
        }

        const insideBox = (y: number, x: number) => {
            const uIn = (u: number, cropU: CropAxisInterface) => {
                return (cropU.lower &lt;= u &amp;&amp; u &lt;= cropU.upper);
            };
            return uIn(depth, cropD) &amp;&amp; uIn(y, cropH) &amp;&amp; uIn(x, cropW);
        };

        const len: number = width * height;
        let uint8data = new Uint8Array(len);

        const rowMajIdx = (yi: number, xj: number) => {
            return xj + yi * width;
        };

        for (let yi = 0; yi &lt; height; ++yi) {
            for (let xj = 0; xj &lt; width; ++xj) {
                if (!insideBox(yi, xj,)) {
                    const idx = rowMajIdx(yi, xj);//* 4;
                    uint8data[idx] = 255;
                }
            }
        }
        const texture = this.textureFromSlice(uint8data, width, height);
        this.cropSlice.texture = texture;
    }

    private toUint8Array(img: NdArray&lt;TypedArray>): Uint8Array {

        let uint8data: Uint8Array;

        const x = img.shape[1];
        const y = img.shape[0];

        const len = x * y;

        //TODO: implement for another dtypes
        if (img.dtype === 'uint8') {
            uint8data = img.data as Uint8Array;
        } else if (img.dtype === 'uint16') {
            const max = 65535.0 * this.imgMax;
            const min = 65535.0 * this.imgMin;
            const range = max - min;
            uint8data = new Uint8Array(len);
            for (let i = 0; i &lt; len; ++i) {
                const val = clamp(min, img.data[i], max);
                const x = 255 * (1.0 - (max - val) / range);
                uint8data[i] = x;
            }
        } else {
            uint8data = new Uint8Array(len);
            for (let i = 0; i &lt; len; ++i) {
                const val = clamp(0.0, img.data[i], 1.0);
                const x = 255 * val;
                uint8data[i] = x;
            }
        }

        return uint8data;
    }

    setFutureImage(futureSlice: NdArray&lt;TypedArray>) {
        this.futureData = futureSlice;

        const x = futureSlice.shape[1];
        const y = futureSlice.shape[0];

        const uint8data = this.toUint8Array(futureSlice);
        const texture = this.textureFromSlice(uint8data, x, y);

        this.futureSlice.texture = texture;
    }

    deleteFutureImage() {
        this.futureData = undefined;
        this.futureSlice.texture = PIXI.Texture.EMPTY;
    }

    setMaintainExtend(flag: boolean) {
        this.maintainExtendLabel = flag;
    }

    setImage(imgSlice: NdArray&lt;TypedArray>) {

        this.imgData = imgSlice;

        const uint8data = this.toUint8Array(imgSlice);

        const x = imgSlice.shape[1];
        const y = imgSlice.shape[0];

        this.x = x;
        this.y = y;

        this.annotation.setSize(x, y);

        const texture = this.textureFromSlice(uint8data, x, y);
        this.slice.texture = texture;

        // console.log('Image exists: Unlocking components.');
        // dispatch('LockComponents', false);
    }

    increaseBrushSize() {
        this.brush.setSize(this.brush.size + 1);
    }

    decreaseBrushSize() {
        if (this.brush.size &lt;= 2)
            return;
        this.brush.setSize(this.brush.size - 1);
    }

    setSuperpixelColor(color: number) {
        this.superpixelColor = color;
        this.superpixelSlice.tint = this.superpixelColor;
    }

    setCropColor(color: number) {
        this.cropColor = color;
        this.cropSlice.tint = this.cropColor;
    }

    setSuperpixelImage(superpixel_slice: NdArray&lt;TypedArray>) {
        const uint8data = superpixel_slice.data.map(x => x * 255) as Uint8Array;
        const x = superpixel_slice.shape[1];
        const y = superpixel_slice.shape[0];
        const texture = this.textureFromSlice(uint8data, x, y);
        this.superpixelSlice.texture = texture;
    }

    destroyImage() {
        this.slice.texture.destroy();
        this.slice.texture = PIXI.Texture.EMPTY;
    }

    destroySuperpixelImage() {
        this.superpixelSlice.texture.destroy();
        this.superpixelSlice.texture = PIXI.Texture.EMPTY;
    }

    resize() {
        console.log('Canvas: resize');
        const center = this.viewport.center;

        this.app.renderer.resize(this.div.offsetWidth, this.div.offsetHeight);
        this.viewport.resize(this.div.offsetWidth, this.div.offsetHeight);

        this.viewport.moveCenter(center);
    }

    recenter(w: number = this.x, h: number = this.y) {
        this.viewport.moveCenter(w / 2, h / 2);
        this.viewport.fit(true, w, h);
    }
}

type brush_mode_type = 'draw_brush' | 'erase_brush' | 'no_brush';

interface ICanvasProps {
    slice: number;
    axis: 'XY' | 'XZ' | 'YZ';
    canvasMode: 'drawing' | 'imaging';
}

interface ICanvasState {
    brush_mode: brush_mode_type;
    label_contour: boolean;
    future_sight_on: boolean;
}

const brushList = [
    {
        id: 'draw_brush',
        logo: brush
    },
    {
        id: 'erase_brush',
        logo: browsers
    },
];

class CanvasContainer extends Component&lt;ICanvasProps, ICanvasState> {

    pixi_container: HTMLDivElement | null;
    canvas: Canvas | null;

    onLabelSelected: (payload: any) => void = () => {
    };
    onImageLoaded: (payload: any) => void = () => {
    };
    onContrastChanged: (payload: number[]) => void = () => {
    };
    onSuperpixelChanged: () => void = () => {
    };
    onLabelChanged: () => void = () => {
    };
    onSuperpixelColorChanged: (color: any) => void = () => {
    };
    onSuperpixelVisibilityChanged: (visible: boolean) => void = () => {
    };
    onLabelVisibilityChanged: (visible: boolean) => void = () => {
    };
    onLabelAlphaChanged: (alpha: number) => void = () => {
    };
    onAnnotanionAlphaChanged!: (alpha: number) => void;
    onAnnotanionVisibilityChanged!: (visible: boolean) => void;
    onLabelColorsChanged!: (colors: { id: number, color: [number, number, number] }[]) => void;
    onAnnotationChanged!: () => void;
    onLabelContourChanged!: (contour: boolean) => void;
    onFutureChanged!: (hasPreview: boolean) => void;
    onChangeStateBrush: (mode: brush_mode_type) => void = () => {
    };
    onExtendLabel: (flag: boolean) => void = () => {
    };
    onExtendLabelOnMerge: (flag: boolean) => void = () => {
    }
    onCropPreviewMode: (activateCropPreview: boolean) => void = () => {
    };
    onCropShape: (cropShape: CropShapeInterface) => void = () => {
    };
    onCropPreviewColorChanged: (color: any) => void = () => {
    };
    onActivateSL: (sequentialLabelPayload: { isActivated: boolean, id: number }) => void = () => {
    };
    onSplitLabel: (flag: boolean) => void = () => {
    }

    constructor(props: ICanvasProps) {
        super(props);
        this.pixi_container = null;
        this.canvas = null;
        this.state = {
            brush_mode: 'draw_brush',
            label_contour: false,
            future_sight_on: false,
        };
    }

    fetchAll = (recenter: boolean = false) => {
        console.log("update ...", this.props.slice);
        return this.getImageSlice()
            .then(() => {
                console.log('Canvas: ImageSlice exists: Unlocking components.');
                dispatch('LockComponents', false);
                this.canvas!.setImageShape();
                if (recenter) {
                    this.canvas!.recenter();
                }
                this.getSuperpixelSlice();
                this.getAnnotSlice();
                this.getLabelSlice();
                this.getFutureSlice();
            });
    }

    fetchAllDebounced = debounce(this.fetchAll, 250);

    newAnnotation() {
        sfetch('POST', '/new_annot/annotation');
        console.log("new annotation_menu, hue");
    }

    getSuperpixelSlice() {

        const params = {
            axis: this.props.axis,
            slice: this.props.slice,
        };

        sfetch('POST', '/get_superpixel_slice', JSON.stringify(params), 'gzip/numpyndarray')
            .then((superpixelSlice) => {
                this.canvas!!.setSuperpixelImage(superpixelSlice);
            })
            .catch(() => {
                this.canvas!!.destroySuperpixelImage()
            });
    }

    getImageSlice() {

        const params = {
            'axis': this.props.axis,
            'slice': this.props.slice,
        };

        return sfetch('POST', '/get_image_slice/image', JSON.stringify(params), 'gzip/numpyndarray')
            .then(imgSlice => {
                this.canvas!!.setImage(imgSlice);
            });
    }

    getFutureSlice() {

        //the preview image is just a single slice
        //so we always get the 0th XY slice
        const params = {
            'axis': 'XY',
            'slice': 0
        };

        sfetch('POST', '/get_image_slice/future', JSON.stringify(params), 'gzip/numpyndarray')
            .then(previewSlice => {
                this.canvas?.setFutureImage(previewSlice);
                this.canvas?.setPreviewVisibility(true);
                this.setState({...this.state, future_sight_on: true});
            });
    }

    getAnnotSlice() {

        const params = {
            axis: this.props.axis,
            slice: this.props.slice,
        };

        console.log('get annot slice', params);
        sfetch('POST', '/get_annot_slice', JSON.stringify(params), 'gzip/numpyndarray')
            .then((slice) => {
                console.log('annot slice');
                this.canvas!!.annotation.draw(slice);
            });
    }

    getLabelSlice() {

        const params = {
            axis: this.props.axis,
            slice: this.props.slice,
            contour: this.state.label_contour
        };

        sfetch('POST', '/get_image_slice/label', JSON.stringify(params), 'gzip/numpyndarray')
            .then(labelSlice => {
                this.canvas!!.setLabelImage(labelSlice);
            });

    }

    setBrushMode(brush_mode: brush_mode_type) {
        this.setState({brush_mode: brush_mode});
        this.canvas!!.setBrushMode(brush_mode);
    }

    componentDidMount() {
        // the element is the DOM object that we will use as container to add pixi stage(canvas)
        const elem = this.pixi_container;
        if (this &amp;&amp; elem) {
            this.canvas = new Canvas(elem, defaultColormap, this.props.axis, this.props.slice);
            setTimeout(() => this.canvas!.resize(), 200);
            console.log(this.canvas.viewport);
            console.log(this.pixi_container);

            window.addEventListener('resize', (evt) => {
                console.log('resize ', evt);
                this.canvas!.resize();
            });


            this.fetchAll(true);

            this.onLabelSelected = (payload: { id: number }) => {
                console.log(payload);
                console.log('label selected');
                this.canvas?.brush.setLabel(payload.id);
            };

            this.onImageLoaded = (payload) => {
                const promise = this.fetchAll(true);
                promise?.then(() => {
                    sfetch("POST", "/is_annotation_empty", "", "json")
                        .then((createNewAnnot: boolean) => {
                            if (createNewAnnot) {
                                this.newAnnotation();
                            }
                        });
                });
            };

            this.onSuperpixelChanged = () => {
                this.getSuperpixelSlice();
            }

            this.onSuperpixelColorChanged = (color) => {
                console.log('superpixel color changed: ', color);
                this.canvas?.setSuperpixelColor(color);
            }

            this.onCropPreviewColorChanged = (color) => {
                console.log('crop preview color changed: ', color);
                this.canvas?.setCropColor(color);
            }

            this.onContrastChanged = (payload: number[]) => {
                this.adjustContrast(payload[0], payload[1]);
            }

            this.onLabelChanged = () => {
                console.log('onlabelchanged ...');
                this.getLabelSlice();
            }

            this.onSuperpixelVisibilityChanged = (visible: boolean) => {
                this.canvas?.setSuperpixelVisibility(visible);
            }

            this.onLabelVisibilityChanged = (visible: boolean) => {
                this.canvas?.setLabelVisibility(visible);
            }

            this.onLabelAlphaChanged = (alpha: number) => {
                this.canvas?.setLabelAlpha(alpha);
            }

            this.onAnnotanionAlphaChanged = (alpha: number) => {
                this.canvas?.setAnnotationAlpha(alpha);
            }

            this.onAnnotanionVisibilityChanged = (visible: boolean) => {
                this.canvas?.setAnnotationVisibility(visible);
            }

            this.onLabelColorsChanged = (colors) => {
                this.canvas?.setColor(colors);
                console.log('colors received: ', colors);
            }

            this.onAnnotationChanged = () => {
                this.getAnnotSlice();
            }

            this.onLabelContourChanged = (contour: boolean) => {
                this.setState({...this.state, label_contour: contour});
                this.getLabelSlice();
                console.log('contour changed: ', contour);
            }

            this.onFutureChanged = (hasSlice: boolean) => {
                if (hasSlice) {
                    this.getFutureSlice();
                } else {
                    this.canvas?.deleteFutureImage();
                    this.setState({...this.state, future_sight_on: false});
                }
            }

            this.onChangeStateBrush = (mode: brush_mode_type) => {
                this.setBrushMode(mode);
            }

            this.onExtendLabel = (flag: boolean) => {
                console.log("flag val : ", flag);
                this.canvas!!.setExtendLabel(flag);
                this.canvas!!.showBrush(false);
            }

            this.onExtendLabelOnMerge = (flag: boolean) => {
                this.canvas!!.setMaintainExtend(flag);
                if (flag) {
                    this.onExtendLabel(flag);
                }
            }

            this.onCropPreviewMode = (activateCropPreview: boolean) => {
                this.cropPreviewMode(activateCropPreview);
            }

            this.onCropShape = (cropShape: CropShapeInterface) => {
                this.setCropShape(cropShape);
            }

            this.onActivateSL = (sequentialLabelPayload: { isActivated: boolean, id: number }) => {
                this.canvas?.setSequentialLabel(sequentialLabelPayload.isActivated);
                this.canvas?.brush.setLabel(sequentialLabelPayload.id);
            }

            this.onSplitLabel = (flag: boolean) => {
                this.onActivateSL({
                    isActivated: flag,
                    id: this.canvas!!.getLabelTableLen(),
                });
            }

            subscribe('futureChanged', this.onFutureChanged);
            subscribe('labelColorsChanged', this.onLabelColorsChanged);
            subscribe('labelContourChanged', this.onLabelContourChanged);
            subscribe('annotationChanged', this.onAnnotationChanged);
            subscribe('annotationVisibilityChanged', this.onAnnotanionVisibilityChanged);
            subscribe('annotationAlphaChanged', this.onAnnotanionAlphaChanged);
            subscribe('labelAlphaChanged', this.onLabelAlphaChanged);
            subscribe('labelVisibilityChanged', this.onLabelVisibilityChanged);
            subscribe('superpixelVisibilityChanged', this.onSuperpixelVisibilityChanged);
            subscribe('superpixelColorChanged', this.onSuperpixelColorChanged);
            subscribe('labelSelected', this.onLabelSelected);
            subscribe('superpixelChanged', this.onSuperpixelChanged);
            subscribe('contrastChanged', this.onContrastChanged);
            subscribe('labelChanged', this.onLabelChanged);
            subscribe('ImageLoaded', this.onImageLoaded);
            subscribe("ChangeStateBrush", this.onChangeStateBrush);
            subscribe("ExtendLabel", this.onExtendLabel);
            subscribe("extendLabelOnMerge", this.onExtendLabelOnMerge);
            subscribe('cropShape', this.onCropShape);
            subscribe('cropPreviewMode', this.onCropPreviewMode);
            subscribe('cropPreviewColorchanged', this.onCropPreviewColorChanged);
            subscribe("activateSL", this.onActivateSL);
            subscribe("splitLabel", this.onSplitLabel);
        }
    }

    componentWillUnmount() {
        unsubscribe('futureChanged', this.onFutureChanged);
        unsubscribe('labelColorsChanged', this.onLabelColorsChanged);
        unsubscribe('labelContourChanged', this.onLabelContourChanged);
        unsubscribe('labelColorsChanged', this.onLabelColorsChanged);
        unsubscribe('annotationChanged', this.onAnnotationChanged);
        unsubscribe('annotationVisibilityChanged', this.onAnnotanionVisibilityChanged);
        unsubscribe('annotationAlphaChanged', this.onAnnotanionAlphaChanged);
        unsubscribe('labelAlphaChanged', this.onLabelAlphaChanged);
        unsubscribe('labelVisibilityChanged', this.onLabelVisibilityChanged);
        unsubscribe('superpixelVisibilityChanged', this.onSuperpixelVisibilityChanged);
        unsubscribe('superpixelColorChanged', this.onSuperpixelColorChanged);
        unsubscribe('labelSelected', this.onLabelSelected);
        unsubscribe('ImageLoaded', this.onImageLoaded);
        unsubscribe('superpixelChanged', this.onSuperpixelChanged);
        unsubscribe('contrastChanged', this.onContrastChanged);
        unsubscribe('labelChanged', this.onLabelChanged);
        unsubscribe("ChangeStateBrush", this.onChangeStateBrush);
        unsubscribe("ExtendLabel", this.onExtendLabel);
        unsubscribe("extendLabelOnMerge", this.onExtendLabelOnMerge);
        unsubscribe('cropShape', this.onCropShape);
        unsubscribe('cropPreviewMode', this.onCropPreviewMode);
        unsubscribe('cropPreviewColorchanged', this.onCropPreviewColorChanged);
        unsubscribe("activateSL", this.onActivateSL);
        unsubscribe("splitLabel", this.onSplitLabel);
    }

    componentDidUpdate(prevProps: ICanvasProps, prevState: ICanvasState) {

        if (isEqual(prevProps, this.props))
            return;

        if (this.props.canvasMode !== prevProps.canvasMode) {
            if (this.props.canvasMode === 'imaging') {
                this.setBrushMode('no_brush');
            } else {
                this.setBrushMode('draw_brush')
            }
        }

        this.setState({...this.state, future_sight_on: false});
        this.canvas?.setSliceNum(this.props.slice);
        this.canvas?.setAxis(this.props.axis);
        this.fetchAllDebounced(true);

    }

    adjustContrast(minimum: number, maximum: number) {
        //this.setState({...this.state, contrastMin: minimum});
        this.canvas?.adjustContrast(minimum, maximum);
    }

    updateCropPreview = () => {
        this.canvas?.checkUpdateCropPreview();
    }

    cropPreviewMode(activateCropPreview: boolean) {
        this.canvas?.setCropVisibility(activateCropPreview);
    }

    setCropShape(cropShape: CropShapeInterface) {
        this.canvas?.setCropShape(cropShape);
    }

    render() {
        return (
            &lt;div id="root" className="canvas" style={{"backgroundColor": "transparent"}}
                 ref={elem => this.pixi_container = elem}>

                &lt;IonFab vertical="bottom" horizontal="start">
                    &lt;IonFabButton color="medium" onClick={() => this.canvas?.recenter()}>
                        &lt;IonIcon icon={expand}/>
                    &lt;/IonFabButton>
                &lt;/IonFab>

                &lt;IonFab hidden={this.props.canvasMode !== 'imaging'} vertical="bottom" horizontal="end">
                    &lt;IonFabButton color="dark"
                                  onClick={() => {
                                      const futureSightVisibility = !this.state.future_sight_on;
                                      this.setState({...this.state, future_sight_on: futureSightVisibility});
                                      this.canvas?.setPreviewVisibility(futureSightVisibility);
                                  }}>
                        &lt;IonIcon icon={this.state.future_sight_on ? eye : eyeOff}/>
                    &lt;/IonFabButton>
                &lt;/IonFab>

                &lt;IonFab hidden={this.props.canvasMode !== 'drawing'} vertical="bottom" horizontal="end">
                    &lt;MenuFabButton value={this.state.brush_mode} openSide="start" buttonsList={brushList}
                                   onChange={(b) => {
                                       console.log("change icon : ", b.id);
                                       this.setBrushMode(b.id as brush_mode_type)
                                   }}/>
                &lt;/IonFab>
                &lt;IonFab vertical="bottom" horizontal="end" style={{marginBottom: '4em'}}>
                    &lt;IonFabButton size="small" onClick={() => {
                        this.canvas?.increaseBrushSize();
                    }}>
                        &lt;IonIcon icon={add}/>
                    &lt;/IonFabButton>
                    &lt;IonFabButton size="small" title="Decrease brush/eraser size" onClick={() => {
                        this.canvas?.decreaseBrushSize();
                    }}>
                        &lt;IonIcon icon={remove}/>
                    &lt;/IonFabButton>
                &lt;/IonFab>

            &lt;/div>
        );
    }
}

export default CanvasContainer;
</code></pre>
        </article>
    </section>




            </div>
            
            <footer class="footer">
                <div class="content has-text-centered">
                    <p>Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 4.0.2</a></p>
                    <p class="sidebar-created-by">
                        <a href="https://github.com/SoftwareBrothers/better-docs" target="_blank">BetterDocs theme</a> provided with <i class="fas fa-heart"></i> by
                        <a href="http://softwarebrothers.co" target="_blank">SoftwareBrothers - JavaScript Development Agency</a>
                    </p>
                </div>
            </footer>
            
        </div>
        <div id="side-nav" class="side-nav">
        </div>
    </div>
<script src="scripts/app.min.js"></script>
<script>PR.prettyPrint();</script>
<script src="scripts/linenumber.js"> </script>

<script src="scripts/search.js"> </script>


</body>
</html>
